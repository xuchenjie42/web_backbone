(function() {
  'use strict';

  var _ = require('underscore');
  var fs = require('fs-extra-promise');
  // var zip = require('gulp-zip');
  var Promise = require('promise');

  var base = require('../task');

  module.exports = base.extend({
    name: 'package',
    execute: function() {
      var dst = this.dst || '/dist';
      var promise = Promise.resolve();
      var alias = this.alias;
      var src = this.src;
      var files = this.files || [];
    
      if(alias.ignore && alias.ignore.length && alias.path) {
        promise = fs.readJsonAsync(alias.path).then(function(json) {
          _.each(json, function(value, key) {
            if(alias.ignore.indexOf(key) === -1) {
              if(fs.existsSync('./' + value)) {
                files.push({ from: './' + value, to: '/' + value });
              }else{
                files.push({ from: './' + value + '.js', to: '/' + value + '.js' });
              }
            }
          });
          return Promise.resolve();
        });
      }
    
      return promise.then(function() {
        return fs.removeAsync(dst).then(function() {
          return fs.copySync(src, dst);
        }).then(function() {
          return Promise.all(files.reduce(function(memo, item) {
            var from = item.from || item;
            if(fs.existsSync(from)) {
              memo.push(fs.copySync(from, dst +
                (typeof item === 'string' ? item.replace(/^./, '') : item.to)));
            }
            return memo;
          }, []));
        });
      });
      // .then(function() {
        // this.gulp.src([dst + '/**/*',
                       // '!' + dst + '/**/*DS_Store'])
          // .pipe(zip(this.parent.name + '.zip'))
          // .pipe(this.gulp.dest(dst));
      // }.bind(this));
    }
  }, { export: 'Package', config: ['alias', 'ignore', 'files'] });
})();