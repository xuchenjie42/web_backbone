'use strict';

(function() {
  var _ = require('underscore-plus');
  var argv = require('yargs').argv;
  var ee = require('event-emitter');
  var fs = require('fs');
  var plugins = require('./plugins');
  var Strings = require('./util/strings');
  var Promise = require('promise');

  var _findCallback = function(parent, name) {
    while(parent) {
      if(parent[name] && typeof parent[name] === 'function') { return parent[name].bind(parent); }
      parent = parent.parent;
    }

    return null;
  };

  var Task = function(gulp, plugins, config) {
    config = config || {};

    this.gulp = gulp || config.gulp || global.gulp || require('gulp');

    _.extend(this, _.pick(config, this.klass.options));

    _.extend(this, _.merge(_.pick(this, this.klass.config),
      _.pick(config, this.klass.config)));

    this.tasks = this.tasks || {};

    config.tasks && _.each(config.tasks, function(value, key) {
      this.tasks[key] = value;
    }.bind(this));

    this.config = config;
    this.plugins = plugins;

    this.gulp.on('task_stop', this.onStop.bind(this));

    this.bind();
  };

  Task.prototype = {
    execute: function() {
      this.emit('execute', this);
      return Promise.resolve();
    },
    onStop: function(event) {
      if(event.task === this.name) {
        this.emit('stop', this);
      }
    },
    bind: function() {
      var tasks = this.addTasks(this.tasks);
      var to = this.config.watch ? 'watch' : 'execute';
      var run = (this.config.callback && this.config.callback[to]) ||
        _findCallback(this, this.name);

      var callback = run ? function() {
        return run(this);
      }.bind(this) : (this[to] && this[to].bind(this));

      this.gulp.task.call(this.gulp,
                          this.name,
                          _.keys(tasks),
                          callback);

      this.emit('bind', this);
    },
    addTasks: function(tasks) {
      var all = process.argv.reduce(function(memo, value) {
        if(/^--/.exec(value)) {
          return memo && false;
        }
        return memo && true;
      }, true);

      tasks = all ? tasks : _.reduce(tasks, function(memo, value, key) {
        if(argv[key]) {
          memo[key] = value;
          process.argv.splice(process.argv.indexOf('--' + key), 1);
        }
        return memo;
      }, {});

      _.each(tasks, function(value, key) {
        this.addTask(key, value);
      }.bind(this));

      return tasks;
    },
    addTask: function(name, config) {
      var task;
      var path = process.cwd() + '/build/' + this.name + '/task/' + name;
      var will = _findCallback(this, 'will' + Strings.toProperCase(name));

      if(fs.existsSync(path + '.js')) {
        task = require(path);
      } else if(fs.existsSync(__dirname + '/task/' + name + '.js')) {
        task = require('./task/' + name);
      } else {
        path = process.cwd() + '/build/' + process.env.scheme + '/task/' + name;

        if(fs.existsSync(path + '.js')) {
          task = require(path);
        } else {
          task = Task.extend({
            name: name,
            tasks: config.tasks
          });
        }
      }

      will && will(task);

      task = new task(this.gulp,
        plugins,
        _.extend({ parent: this }, config));

      task.once('stop', function(e) {
        var did = _findCallback(this, 'did' + Strings.toProperCase(e.name));
        did && did(e);
      }.bind(this));

      return task;
    }
  };

  ee(Task.prototype);

  var extend = require('class-extend').extend;

  Task.extend = function(props, statics) {
    var subclass = extend.apply(this, arguments);

    if(statics && statics.export) {
      Task[statics.export] = subclass;
    }

    subclass.prototype.klass = subclass;
    subclass.config = this.config.concat((statics && statics.config) || []);

    return subclass;
  };

  Task.options = ['name', 'callback', 'parent'];
  Task.config = ['src', 'dst'];
  Task.klass = Task;

  module.exports = Task;
})();
